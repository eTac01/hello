import{h as t,C as e,P as i,j as o,A as s,k as n,V as r,a,g as h,G as u,i as l,f as g,r as d}from"./index-DI5LSjs4.js";import{B as m}from"./BaseExperience-CpvtY6rA.js";class v extends m{constructor(t,e,i){super(t,e,i),this.leftLight=null,this.rightLight=null,this.embraceProgress=0}getInstruction(){return"Bring them together..."}getCompletionMessage(){return"In an embrace,<br>two become one warmth."}async init(){this.createLights(),this.createWarmthField(),this.setupInteraction(),await super.init(),this.unsubscribeUpdate=this.sceneManager.onUpdate(this.update.bind(this))}createLights(){const i=(t,e)=>{const i=new u,r=new a(new l(.3,32,32),new g({color:t,transparent:!0,opacity:.9}));i.add(r);const h=new a(new l(.5,32,32),new o({uniforms:{uColor:{value:new n(t)},uTime:{value:0}},vertexShader:"\n            varying vec3 vNormal;\n            void main() {\n              vNormal = normalize(normalMatrix * normal);\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n          ",fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uTime;\n            varying vec3 vNormal;\n            \n            void main() {\n              float pulse = sin(uTime * 2.0) * 0.1 + 0.9;\n              float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 3.0);\n              gl_FragColor = vec4(uColor, fresnel * 0.6 * pulse);\n            }\n          ",transparent:!0,side:d,blending:s}));return i.add(h),i.position.copy(e),i.userData={core:r,glow:h},i};this.leftLight=i(e.champagneGold,new t(-3,0,0)),this.rightLight=i(e.roseRed,new t(3,0,0)),this.group.add(this.leftLight),this.group.add(this.rightLight)}createWarmthField(){const t=new i(12,12,32,32),h=new o({uniforms:{uTime:{value:0},uProgress:{value:0},uLeftPos:{value:new r(-3,0)},uRightPos:{value:new r(3,0)},uColor1:{value:new n(e.champagneGold)},uColor2:{value:new n(e.roseRed)}},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform float uTime;\n        uniform float uProgress;\n        uniform vec2 uLeftPos;\n        uniform vec2 uRightPos;\n        uniform vec3 uColor1;\n        uniform vec3 uColor2;\n        varying vec2 vUv;\n        \n        void main() {\n          vec2 pos = (vUv - 0.5) * 12.0;\n          \n          float distLeft = length(pos - uLeftPos);\n          float distRight = length(pos - uRightPos);\n          \n          float glow1 = 1.0 / (distLeft * distLeft + 0.5);\n          float glow2 = 1.0 / (distRight * distRight + 0.5);\n          \n          vec3 color = uColor1 * glow1 + uColor2 * glow2;\n          \n          // Merge glow when close\n          float mergeDist = length(uLeftPos - uRightPos);\n          float mergeGlow = smoothstep(2.0, 0.5, mergeDist) * uProgress;\n          \n          float alpha = (glow1 + glow2) * 0.1 + mergeGlow * 0.3;\n          \n          gl_FragColor = vec4(color, alpha);\n        }\n      ",transparent:!0,depthWrite:!1,blending:s});this.warmthField=new a(t,h),this.warmthField.position.z=-.1,this.group.add(this.warmthField)}setupInteraction(){this.mousePos={x:0,y:0},this.isDragging=null,this.boundMouseMove=t=>{"touchmove"===t.type&&t.preventDefault();const e=t.clientX||t.touches&&t.touches[0]&&t.touches[0].clientX,i=t.clientY||t.touches&&t.touches[0]&&t.touches[0].clientY;if(void 0!==e&&void 0!==i&&(this.mousePos.x=e/window.innerWidth*2-1,this.mousePos.y=-i/window.innerHeight*2+1,this.isDragging)){const t="left"===this.isDragging?this.leftLight:this.rightLight;h.to(t.position,{x:4*this.mousePos.x,y:3*this.mousePos.y,duration:.2})}},this.boundMouseDown=t=>{"touchstart"===t.type&&t.preventDefault();const e=Math.hypot(4*this.mousePos.x-this.leftLight.position.x,3*this.mousePos.y-this.leftLight.position.y),i=Math.hypot(4*this.mousePos.x-this.rightLight.position.x,3*this.mousePos.y-this.rightLight.position.y);e<1.5?this.isDragging="left":i<1.5&&(this.isDragging="right")},this.boundMouseUp=t=>{t&&"touchend"===t.type&&t.preventDefault(),this.isDragging=null},window.addEventListener("mousemove",this.boundMouseMove),window.addEventListener("mousedown",this.boundMouseDown),window.addEventListener("mouseup",this.boundMouseUp),window.addEventListener("touchmove",this.boundMouseMove,{passive:!1}),window.addEventListener("touchstart",this.boundMouseDown,{passive:!1}),window.addEventListener("touchend",this.boundMouseUp,{passive:!1})}update(t,e){if(!this.isActive)return;[this.leftLight,this.rightLight].forEach(t=>{t.userData.glow.material.uniforms&&(t.userData.glow.material.uniforms.uTime.value=e)});const i=this.leftLight.position.distanceTo(this.rightLight.position);this.embraceProgress=Math.max(0,1-i/6),this.warmthField.material.uniforms.uTime.value=e,this.warmthField.material.uniforms.uProgress.value=this.embraceProgress,this.warmthField.material.uniforms.uLeftPos.value.set(this.leftLight.position.x,this.leftLight.position.y),this.warmthField.material.uniforms.uRightPos.value.set(this.rightLight.position.x,this.rightLight.position.y),i<.8&&!this.isCompleted&&this.onEmbraceComplete()}async onEmbraceComplete(){const t=this.leftLight.position.clone().add(this.rightLight.position).multiplyScalar(.5);h.to(this.leftLight.position,{x:t.x,y:t.y,duration:1,ease:"power2.in"}),h.to(this.rightLight.position,{x:t.x,y:t.y,duration:1,ease:"power2.in"}),h.to(this.warmthField.material.uniforms.uProgress,{value:3,duration:2,ease:"power2.out",onComplete:()=>this.complete()})}dispose(){this.unsubscribeUpdate&&this.unsubscribeUpdate(),window.removeEventListener("mousemove",this.boundMouseMove),window.removeEventListener("mousedown",this.boundMouseDown),window.removeEventListener("mouseup",this.boundMouseUp),window.removeEventListener("touchmove",this.boundMouseMove),window.removeEventListener("touchstart",this.boundMouseDown),window.removeEventListener("touchend",this.boundMouseUp),super.dispose()}}export{v as default};
